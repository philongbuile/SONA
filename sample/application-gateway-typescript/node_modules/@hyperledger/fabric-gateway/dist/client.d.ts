/// <reference types="node" />
import { CallOptions, ClientUnaryCall, requestCallback } from '@grpc/grpc-js';
import { common, gateway, peer } from '@hyperledger/fabric-protos';
import { ConnectOptions } from './gateway';
export declare const evaluateMethod = "/gateway.Gateway/Evaluate";
export declare const endorseMethod = "/gateway.Gateway/Endorse";
export declare const submitMethod = "/gateway.Gateway/Submit";
export declare const commitStatusMethod = "/gateway.Gateway/CommitStatus";
export declare const chaincodeEventsMethod = "/gateway.Gateway/ChaincodeEvents";
export declare const deliverMethod = "/protos.Deliver/Deliver";
export declare const deliverFilteredMethod = "/protos.Deliver/DeliverFiltered";
export declare const deliverWithPrivateDataMethod = "/protos.Deliver/DeliverWithPrivateData";
export interface GatewayClient {
    evaluate(request: gateway.EvaluateRequest, options?: CallOptions): Promise<gateway.EvaluateResponse>;
    endorse(request: gateway.EndorseRequest, options?: CallOptions): Promise<gateway.EndorseResponse>;
    submit(request: gateway.SubmitRequest, options?: CallOptions): Promise<gateway.SubmitResponse>;
    commitStatus(request: gateway.SignedCommitStatusRequest, options?: CallOptions): Promise<gateway.CommitStatusResponse>;
    chaincodeEvents(request: gateway.SignedChaincodeEventsRequest, options?: CallOptions): CloseableAsyncIterable<gateway.ChaincodeEventsResponse>;
    blockEvents(request: common.Envelope, options?: CallOptions): CloseableAsyncIterable<peer.DeliverResponse>;
    filteredBlockEvents(request: common.Envelope, options?: CallOptions): CloseableAsyncIterable<peer.DeliverResponse>;
    blockAndPrivateDataEvents(request: common.Envelope, options?: CallOptions): CloseableAsyncIterable<peer.DeliverResponse>;
}
/**
 * An async iterable that can be closed when the consumer does not want to read any more elements, freeing up resources
 * that may be held by the iterable.
 */
export interface CloseableAsyncIterable<T> extends AsyncIterable<T> {
    /**
     * Close the iterable to free up resources when no more elements are required.
     */
    close(): void;
}
/**
 * Subset of grpc-js ClientReadableStream used by GatewayClient to aid mocking.
 */
export interface ServerStreamResponse<T> extends AsyncIterable<T> {
    cancel(): void;
}
/**
 * Subset of grpc-js ClientDuplexStream used by GatewayClient to aid mocking.
 */
export interface DuplexStreamResponse<RequestType, ResponseType> extends ServerStreamResponse<ResponseType> {
    write(chunk: RequestType): boolean;
}
/**
 * Subset of the grpc-js Client used by GatewayClient to aid mocking.
 */
export interface GatewayGrpcClient {
    makeUnaryRequest<RequestType, ResponseType>(method: string, serialize: (value: RequestType) => Buffer, deserialize: (value: Buffer) => ResponseType, argument: RequestType, options: CallOptions, callback: requestCallback<ResponseType>): ClientUnaryCall;
    makeServerStreamRequest<RequestType, ResponseType>(method: string, serialize: (value: RequestType) => Buffer, deserialize: (value: Buffer) => ResponseType, argument: RequestType, options: CallOptions): ServerStreamResponse<ResponseType>;
    makeBidiStreamRequest<RequestType, ResponseType>(method: string, serialize: (value: RequestType) => Buffer, deserialize: (value: Buffer) => ResponseType, options: CallOptions): DuplexStreamResponse<RequestType, ResponseType>;
}
declare type DefaultCallOptions = Pick<ConnectOptions, 'commitStatusOptions' | 'endorseOptions' | 'evaluateOptions' | 'submitOptions' | 'chaincodeEventsOptions' | 'blockEventsOptions' | 'filteredBlockEventsOptions' | 'blockAndPrivateDataEventsOptions'>;
export declare function newGatewayClient(client: GatewayGrpcClient, defaultOptions: DefaultCallOptions): GatewayClient;
export {};
//# sourceMappingURL=client.d.ts.map