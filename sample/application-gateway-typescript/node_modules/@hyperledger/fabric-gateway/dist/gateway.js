"use strict";
/*
 * Copyright 2020 IBM All Rights Reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _GatewayImpl_client, _GatewayImpl_signingIdentity;
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertDefined = exports.internalConnect = exports.connect = void 0;
const fabric_protos_1 = require("@hyperledger/fabric-protos");
const blockeventsrequest_1 = require("./blockeventsrequest");
const chaincodeeventsrequest_1 = require("./chaincodeeventsrequest");
const client_1 = require("./client");
const commit_1 = require("./commit");
const network_1 = require("./network");
const proposal_1 = require("./proposal");
const signingidentity_1 = require("./signingidentity");
const transaction_1 = require("./transaction");
/**
 * Connect to a Fabric Gateway using a client identity, gRPC connection and signing implementation.
 * @param options - Connection options.
 * @returns A connected gateway.
 */
function connect(options) {
    return internalConnect(options);
}
exports.connect = connect;
function internalConnect(options) {
    if (!options.client) {
        throw new Error('No client connection supplied');
    }
    if (!options.identity) {
        throw new Error('No identity supplied');
    }
    const signingIdentity = new signingidentity_1.SigningIdentity(options);
    const gatewayClient = (0, client_1.newGatewayClient)(options.client, options);
    return new GatewayImpl(gatewayClient, signingIdentity);
}
exports.internalConnect = internalConnect;
class GatewayImpl {
    constructor(client, signingIdentity) {
        _GatewayImpl_client.set(this, void 0);
        _GatewayImpl_signingIdentity.set(this, void 0);
        __classPrivateFieldSet(this, _GatewayImpl_client, client, "f");
        __classPrivateFieldSet(this, _GatewayImpl_signingIdentity, signingIdentity, "f");
    }
    getIdentity() {
        return __classPrivateFieldGet(this, _GatewayImpl_signingIdentity, "f").getIdentity();
    }
    getNetwork(channelName) {
        return new network_1.NetworkImpl({
            client: __classPrivateFieldGet(this, _GatewayImpl_client, "f"),
            signingIdentity: __classPrivateFieldGet(this, _GatewayImpl_signingIdentity, "f"),
            channelName
        });
    }
    newProposal(bytes) {
        const proposedTransaction = fabric_protos_1.gateway.ProposedTransaction.deserializeBinary(bytes);
        const signedProposal = assertDefined(proposedTransaction.getProposal(), 'Missing signed proposal');
        const proposal = fabric_protos_1.peer.Proposal.deserializeBinary(signedProposal.getProposalBytes_asU8());
        const header = fabric_protos_1.common.Header.deserializeBinary(proposal.getHeader_asU8());
        const channelHeader = fabric_protos_1.common.ChannelHeader.deserializeBinary(header.getChannelHeader_asU8());
        const result = new proposal_1.ProposalImpl({
            client: __classPrivateFieldGet(this, _GatewayImpl_client, "f"),
            signingIdentity: __classPrivateFieldGet(this, _GatewayImpl_signingIdentity, "f"),
            channelName: channelHeader.getChannelId(),
            proposedTransaction,
        });
        return result;
    }
    newSignedProposal(bytes, signature) {
        const result = this.newProposal(bytes);
        result.setSignature(signature);
        return result;
    }
    newTransaction(bytes) {
        const preparedTransaction = fabric_protos_1.gateway.PreparedTransaction.deserializeBinary(bytes);
        const result = new transaction_1.TransactionImpl({
            client: __classPrivateFieldGet(this, _GatewayImpl_client, "f"),
            signingIdentity: __classPrivateFieldGet(this, _GatewayImpl_signingIdentity, "f"),
            preparedTransaction,
        });
        return result;
    }
    newSignedTransaction(bytes, signature) {
        const result = this.newTransaction(bytes);
        result.setSignature(signature);
        return result;
    }
    newCommit(bytes) {
        const signedRequest = fabric_protos_1.gateway.SignedCommitStatusRequest.deserializeBinary(bytes);
        const request = fabric_protos_1.gateway.CommitStatusRequest.deserializeBinary(signedRequest.getRequest_asU8());
        const result = new commit_1.CommitImpl({
            client: __classPrivateFieldGet(this, _GatewayImpl_client, "f"),
            signingIdentity: __classPrivateFieldGet(this, _GatewayImpl_signingIdentity, "f"),
            transactionId: request.getTransactionId(),
            signedRequest: signedRequest,
        });
        return result;
    }
    newSignedCommit(bytes, signature) {
        const result = this.newCommit(bytes);
        result.setSignature(signature);
        return result;
    }
    newSignedChaincodeEventsRequest(bytes, signature) {
        const result = this.newChaincodeEventsRequest(bytes);
        result.setSignature(signature);
        return result;
    }
    newChaincodeEventsRequest(bytes) {
        const signedRequest = fabric_protos_1.gateway.SignedChaincodeEventsRequest.deserializeBinary(bytes);
        const result = new chaincodeeventsrequest_1.ChaincodeEventsRequestImpl({
            client: __classPrivateFieldGet(this, _GatewayImpl_client, "f"),
            signingIdentity: __classPrivateFieldGet(this, _GatewayImpl_signingIdentity, "f"),
            signedRequest,
        });
        return result;
    }
    newSignedBlockEventsRequest(bytes, signature) {
        const result = this.newBlockEventsRequest(bytes);
        result.setSignature(signature);
        return result;
    }
    newBlockEventsRequest(bytes) {
        const request = fabric_protos_1.common.Envelope.deserializeBinary(bytes);
        const result = new blockeventsrequest_1.BlockEventsRequestImpl({
            client: __classPrivateFieldGet(this, _GatewayImpl_client, "f"),
            signingIdentity: __classPrivateFieldGet(this, _GatewayImpl_signingIdentity, "f"),
            request,
        });
        return result;
    }
    newSignedFilteredBlockEventsRequest(bytes, signature) {
        const result = this.newFilteredBlockEventsRequest(bytes);
        result.setSignature(signature);
        return result;
    }
    newFilteredBlockEventsRequest(bytes) {
        const request = fabric_protos_1.common.Envelope.deserializeBinary(bytes);
        const result = new blockeventsrequest_1.FilteredBlockEventsRequestImpl({
            client: __classPrivateFieldGet(this, _GatewayImpl_client, "f"),
            signingIdentity: __classPrivateFieldGet(this, _GatewayImpl_signingIdentity, "f"),
            request,
        });
        return result;
    }
    newSignedBlockAndPrivateDataEventsRequest(bytes, signature) {
        const result = this.newBlockAndPrivateDataEventsRequest(bytes);
        result.setSignature(signature);
        return result;
    }
    newBlockAndPrivateDataEventsRequest(bytes) {
        const request = fabric_protos_1.common.Envelope.deserializeBinary(bytes);
        const result = new blockeventsrequest_1.BlockAndPrivateDataEventsRequestImpl({
            client: __classPrivateFieldGet(this, _GatewayImpl_client, "f"),
            signingIdentity: __classPrivateFieldGet(this, _GatewayImpl_signingIdentity, "f"),
            request,
        });
        return result;
    }
    close() {
        // Nothing for now
    }
}
_GatewayImpl_client = new WeakMap(), _GatewayImpl_signingIdentity = new WeakMap();
function assertDefined(value, message) {
    if (value == undefined) {
        throw new Error(message);
    }
    return value;
}
exports.assertDefined = assertDefined;
//# sourceMappingURL=gateway.js.map