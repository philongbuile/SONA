import { CallOptions } from '@grpc/grpc-js';
import { common, peer } from '@hyperledger/fabric-protos';
import { CloseableAsyncIterable, GatewayClient } from './client';
import { Signable } from './signable';
import { SigningIdentity } from './signingidentity';
/**
 * Delivers block events.
 */
export interface BlockEventsRequest extends Signable {
    /**
     * Get block events.
     * @param options - gRPC call
     * @returns Block protocol buffer messages. The iterator should be closed after use to complete the eventing
     * session.
     * @throws {@link GatewayError}
     * Thrown by the iterator if the gRPC service invocation fails.
     * @example
     * ```typescript
     * const blocks = await request.getEvents();
     * try {
     *     for async (const block of blocks) {
     *         // Process block
     *     }
     * } finally {
     *     blocks.close();
     * }
     * ```
     */
    getEvents(options?: CallOptions): Promise<CloseableAsyncIterable<common.Block>>;
}
/**
 * Delivers filtered block events.
 */
export interface FilteredBlockEventsRequest extends Signable {
    /**
     * Get filtered block events.
     * @param options - gRPC call
     * @returns Filtered block protocol buffer messages. The iterator should be closed after use to complete the
     * eventing session.
     * @throws {@link GatewayError}
     * Thrown by the iterator if the gRPC service invocation fails.
     * @example
     * ```typescript
     * const blocks = await request.getEvents();
     * try {
     *     for async (const block of blocks) {
     *         // Process block
     *     }
     * } finally {
     *     blocks.close();
     * }
     * ```
     */
    getEvents(options?: CallOptions): Promise<CloseableAsyncIterable<peer.FilteredBlock>>;
}
/**
 * Delivers block and private data events.
 */
export interface BlockAndPrivateDataEventsRequest extends Signable {
    /**
     * Get block and private data events.
     * @param options - gRPC call
     * @returns Block and private data protocol buffer messages. The iterator should be closed after use to complete
     * the eventing session.
     * @throws {@link GatewayError}
     * Thrown by the iterator if the gRPC service invocation fails.
     * @example
     * ```typescript
     * const events = await network.getBlockAndPrivateEventsData();
     * try {
     *     for async (const event of events) {
     *         // Process block and private data event
     *     }
     * } finally {
     *     events.close();
     * }
     * ```
     */
    getEvents(options?: CallOptions): Promise<CloseableAsyncIterable<peer.BlockAndPrivateData>>;
}
export interface BlockEventsRequestOptions {
    client: GatewayClient;
    signingIdentity: SigningIdentity;
    request: common.Envelope;
}
declare type SignableBlockEventsRequestOptions = Pick<BlockEventsRequestOptions, 'request' | 'signingIdentity'>;
declare class SignableBlockEventsRequest implements Signable {
    #private;
    constructor(options: Readonly<SignableBlockEventsRequestOptions>);
    getBytes(): Uint8Array;
    getDigest(): Uint8Array;
    setSignature(signature: Uint8Array): void;
    protected getSignedRequest(): Promise<common.Envelope>;
}
export declare class BlockEventsRequestImpl extends SignableBlockEventsRequest implements BlockEventsRequest {
    #private;
    constructor(options: Readonly<BlockEventsRequestOptions>);
    getEvents(options?: Readonly<CallOptions>): Promise<CloseableAsyncIterable<common.Block>>;
}
export declare class FilteredBlockEventsRequestImpl extends SignableBlockEventsRequest implements FilteredBlockEventsRequest {
    #private;
    constructor(options: Readonly<BlockEventsRequestOptions>);
    getEvents(options?: Readonly<CallOptions>): Promise<CloseableAsyncIterable<peer.FilteredBlock>>;
}
export declare class BlockAndPrivateDataEventsRequestImpl extends SignableBlockEventsRequest implements BlockAndPrivateDataEventsRequest {
    #private;
    constructor(options: Readonly<BlockEventsRequestOptions>);
    getEvents(options?: Readonly<CallOptions>): Promise<CloseableAsyncIterable<peer.BlockAndPrivateData>>;
}
export {};
//# sourceMappingURL=blockeventsrequest.d.ts.map