// package: orderer
// file: orderer/kafka.proto

import * as jspb from "google-protobuf";

export class KafkaMessage extends jspb.Message {
  hasRegular(): boolean;
  clearRegular(): void;
  getRegular(): KafkaMessageRegular | undefined;
  setRegular(value?: KafkaMessageRegular): void;

  hasTimeToCut(): boolean;
  clearTimeToCut(): void;
  getTimeToCut(): KafkaMessageTimeToCut | undefined;
  setTimeToCut(value?: KafkaMessageTimeToCut): void;

  hasConnect(): boolean;
  clearConnect(): void;
  getConnect(): KafkaMessageConnect | undefined;
  setConnect(value?: KafkaMessageConnect): void;

  getTypeCase(): KafkaMessage.TypeCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): KafkaMessage.AsObject;
  static toObject(includeInstance: boolean, msg: KafkaMessage): KafkaMessage.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: KafkaMessage, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): KafkaMessage;
  static deserializeBinaryFromReader(message: KafkaMessage, reader: jspb.BinaryReader): KafkaMessage;
}

export namespace KafkaMessage {
  export type AsObject = {
    regular?: KafkaMessageRegular.AsObject,
    timeToCut?: KafkaMessageTimeToCut.AsObject,
    connect?: KafkaMessageConnect.AsObject,
  }

  export enum TypeCase {
    TYPE_NOT_SET = 0,
    REGULAR = 1,
    TIME_TO_CUT = 2,
    CONNECT = 3,
  }
}

export class KafkaMessageRegular extends jspb.Message {
  getPayload(): Uint8Array | string;
  getPayload_asU8(): Uint8Array;
  getPayload_asB64(): string;
  setPayload(value: Uint8Array | string): void;

  getConfigSeq(): number;
  setConfigSeq(value: number): void;

  getClass(): KafkaMessageRegular.ClassMap[keyof KafkaMessageRegular.ClassMap];
  setClass(value: KafkaMessageRegular.ClassMap[keyof KafkaMessageRegular.ClassMap]): void;

  getOriginalOffset(): number;
  setOriginalOffset(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): KafkaMessageRegular.AsObject;
  static toObject(includeInstance: boolean, msg: KafkaMessageRegular): KafkaMessageRegular.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: KafkaMessageRegular, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): KafkaMessageRegular;
  static deserializeBinaryFromReader(message: KafkaMessageRegular, reader: jspb.BinaryReader): KafkaMessageRegular;
}

export namespace KafkaMessageRegular {
  export type AsObject = {
    payload: Uint8Array | string,
    configSeq: number,
    pb_class: KafkaMessageRegular.ClassMap[keyof KafkaMessageRegular.ClassMap],
    originalOffset: number,
  }

  export interface ClassMap {
    UNKNOWN: 0;
    NORMAL: 1;
    CONFIG: 2;
  }

  export const Class: ClassMap;
}

export class KafkaMessageTimeToCut extends jspb.Message {
  getBlockNumber(): number;
  setBlockNumber(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): KafkaMessageTimeToCut.AsObject;
  static toObject(includeInstance: boolean, msg: KafkaMessageTimeToCut): KafkaMessageTimeToCut.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: KafkaMessageTimeToCut, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): KafkaMessageTimeToCut;
  static deserializeBinaryFromReader(message: KafkaMessageTimeToCut, reader: jspb.BinaryReader): KafkaMessageTimeToCut;
}

export namespace KafkaMessageTimeToCut {
  export type AsObject = {
    blockNumber: number,
  }
}

export class KafkaMessageConnect extends jspb.Message {
  getPayload(): Uint8Array | string;
  getPayload_asU8(): Uint8Array;
  getPayload_asB64(): string;
  setPayload(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): KafkaMessageConnect.AsObject;
  static toObject(includeInstance: boolean, msg: KafkaMessageConnect): KafkaMessageConnect.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: KafkaMessageConnect, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): KafkaMessageConnect;
  static deserializeBinaryFromReader(message: KafkaMessageConnect, reader: jspb.BinaryReader): KafkaMessageConnect;
}

export namespace KafkaMessageConnect {
  export type AsObject = {
    payload: Uint8Array | string,
  }
}

export class KafkaMetadata extends jspb.Message {
  getLastOffsetPersisted(): number;
  setLastOffsetPersisted(value: number): void;

  getLastOriginalOffsetProcessed(): number;
  setLastOriginalOffsetProcessed(value: number): void;

  getLastResubmittedConfigOffset(): number;
  setLastResubmittedConfigOffset(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): KafkaMetadata.AsObject;
  static toObject(includeInstance: boolean, msg: KafkaMetadata): KafkaMetadata.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: KafkaMetadata, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): KafkaMetadata;
  static deserializeBinaryFromReader(message: KafkaMetadata, reader: jspb.BinaryReader): KafkaMetadata;
}

export namespace KafkaMetadata {
  export type AsObject = {
    lastOffsetPersisted: number,
    lastOriginalOffsetProcessed: number,
    lastResubmittedConfigOffset: number,
  }
}

