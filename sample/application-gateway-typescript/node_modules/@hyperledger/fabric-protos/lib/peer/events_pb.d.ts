// package: protos
// file: peer/events.proto

import * as jspb from "google-protobuf";
import * as common_common_pb from "../common/common_pb";
import * as ledger_rwset_rwset_pb from "../ledger/rwset/rwset_pb";
import * as peer_chaincode_event_pb from "../peer/chaincode_event_pb";
import * as peer_transaction_pb from "../peer/transaction_pb";

export class FilteredBlock extends jspb.Message {
  getChannelId(): string;
  setChannelId(value: string): void;

  getNumber(): number;
  setNumber(value: number): void;

  clearFilteredTransactionsList(): void;
  getFilteredTransactionsList(): Array<FilteredTransaction>;
  setFilteredTransactionsList(value: Array<FilteredTransaction>): void;
  addFilteredTransactions(value?: FilteredTransaction, index?: number): FilteredTransaction;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FilteredBlock.AsObject;
  static toObject(includeInstance: boolean, msg: FilteredBlock): FilteredBlock.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: FilteredBlock, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): FilteredBlock;
  static deserializeBinaryFromReader(message: FilteredBlock, reader: jspb.BinaryReader): FilteredBlock;
}

export namespace FilteredBlock {
  export type AsObject = {
    channelId: string,
    number: number,
    filteredTransactionsList: Array<FilteredTransaction.AsObject>,
  }
}

export class FilteredTransaction extends jspb.Message {
  getTxid(): string;
  setTxid(value: string): void;

  getType(): common_common_pb.HeaderTypeMap[keyof common_common_pb.HeaderTypeMap];
  setType(value: common_common_pb.HeaderTypeMap[keyof common_common_pb.HeaderTypeMap]): void;

  getTxValidationCode(): peer_transaction_pb.TxValidationCodeMap[keyof peer_transaction_pb.TxValidationCodeMap];
  setTxValidationCode(value: peer_transaction_pb.TxValidationCodeMap[keyof peer_transaction_pb.TxValidationCodeMap]): void;

  hasTransactionActions(): boolean;
  clearTransactionActions(): void;
  getTransactionActions(): FilteredTransactionActions | undefined;
  setTransactionActions(value?: FilteredTransactionActions): void;

  getDataCase(): FilteredTransaction.DataCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FilteredTransaction.AsObject;
  static toObject(includeInstance: boolean, msg: FilteredTransaction): FilteredTransaction.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: FilteredTransaction, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): FilteredTransaction;
  static deserializeBinaryFromReader(message: FilteredTransaction, reader: jspb.BinaryReader): FilteredTransaction;
}

export namespace FilteredTransaction {
  export type AsObject = {
    txid: string,
    type: common_common_pb.HeaderTypeMap[keyof common_common_pb.HeaderTypeMap],
    txValidationCode: peer_transaction_pb.TxValidationCodeMap[keyof peer_transaction_pb.TxValidationCodeMap],
    transactionActions?: FilteredTransactionActions.AsObject,
  }

  export enum DataCase {
    DATA_NOT_SET = 0,
    TRANSACTION_ACTIONS = 4,
  }
}

export class FilteredTransactionActions extends jspb.Message {
  clearChaincodeActionsList(): void;
  getChaincodeActionsList(): Array<FilteredChaincodeAction>;
  setChaincodeActionsList(value: Array<FilteredChaincodeAction>): void;
  addChaincodeActions(value?: FilteredChaincodeAction, index?: number): FilteredChaincodeAction;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FilteredTransactionActions.AsObject;
  static toObject(includeInstance: boolean, msg: FilteredTransactionActions): FilteredTransactionActions.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: FilteredTransactionActions, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): FilteredTransactionActions;
  static deserializeBinaryFromReader(message: FilteredTransactionActions, reader: jspb.BinaryReader): FilteredTransactionActions;
}

export namespace FilteredTransactionActions {
  export type AsObject = {
    chaincodeActionsList: Array<FilteredChaincodeAction.AsObject>,
  }
}

export class FilteredChaincodeAction extends jspb.Message {
  hasChaincodeEvent(): boolean;
  clearChaincodeEvent(): void;
  getChaincodeEvent(): peer_chaincode_event_pb.ChaincodeEvent | undefined;
  setChaincodeEvent(value?: peer_chaincode_event_pb.ChaincodeEvent): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FilteredChaincodeAction.AsObject;
  static toObject(includeInstance: boolean, msg: FilteredChaincodeAction): FilteredChaincodeAction.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: FilteredChaincodeAction, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): FilteredChaincodeAction;
  static deserializeBinaryFromReader(message: FilteredChaincodeAction, reader: jspb.BinaryReader): FilteredChaincodeAction;
}

export namespace FilteredChaincodeAction {
  export type AsObject = {
    chaincodeEvent?: peer_chaincode_event_pb.ChaincodeEvent.AsObject,
  }
}

export class BlockAndPrivateData extends jspb.Message {
  hasBlock(): boolean;
  clearBlock(): void;
  getBlock(): common_common_pb.Block | undefined;
  setBlock(value?: common_common_pb.Block): void;

  getPrivateDataMapMap(): jspb.Map<number, ledger_rwset_rwset_pb.TxPvtReadWriteSet>;
  clearPrivateDataMapMap(): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): BlockAndPrivateData.AsObject;
  static toObject(includeInstance: boolean, msg: BlockAndPrivateData): BlockAndPrivateData.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BlockAndPrivateData, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BlockAndPrivateData;
  static deserializeBinaryFromReader(message: BlockAndPrivateData, reader: jspb.BinaryReader): BlockAndPrivateData;
}

export namespace BlockAndPrivateData {
  export type AsObject = {
    block?: common_common_pb.Block.AsObject,
    privateDataMapMap: Array<[number, ledger_rwset_rwset_pb.TxPvtReadWriteSet.AsObject]>,
  }
}

export class DeliverResponse extends jspb.Message {
  hasStatus(): boolean;
  clearStatus(): void;
  getStatus(): common_common_pb.StatusMap[keyof common_common_pb.StatusMap];
  setStatus(value: common_common_pb.StatusMap[keyof common_common_pb.StatusMap]): void;

  hasBlock(): boolean;
  clearBlock(): void;
  getBlock(): common_common_pb.Block | undefined;
  setBlock(value?: common_common_pb.Block): void;

  hasFilteredBlock(): boolean;
  clearFilteredBlock(): void;
  getFilteredBlock(): FilteredBlock | undefined;
  setFilteredBlock(value?: FilteredBlock): void;

  hasBlockAndPrivateData(): boolean;
  clearBlockAndPrivateData(): void;
  getBlockAndPrivateData(): BlockAndPrivateData | undefined;
  setBlockAndPrivateData(value?: BlockAndPrivateData): void;

  getTypeCase(): DeliverResponse.TypeCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DeliverResponse.AsObject;
  static toObject(includeInstance: boolean, msg: DeliverResponse): DeliverResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DeliverResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DeliverResponse;
  static deserializeBinaryFromReader(message: DeliverResponse, reader: jspb.BinaryReader): DeliverResponse;
}

export namespace DeliverResponse {
  export type AsObject = {
    status: common_common_pb.StatusMap[keyof common_common_pb.StatusMap],
    block?: common_common_pb.Block.AsObject,
    filteredBlock?: FilteredBlock.AsObject,
    blockAndPrivateData?: BlockAndPrivateData.AsObject,
  }

  export enum TypeCase {
    TYPE_NOT_SET = 0,
    STATUS = 1,
    BLOCK = 2,
    FILTERED_BLOCK = 3,
    BLOCK_AND_PRIVATE_DATA = 4,
  }
}

