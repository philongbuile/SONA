// package: protos
// file: peer/proposal_response.proto

import * as jspb from "google-protobuf";
import * as google_protobuf_timestamp_pb from "google-protobuf/google/protobuf/timestamp_pb";
import * as common_policies_pb from "../common/policies_pb";

export class ProposalResponse extends jspb.Message {
  getVersion(): number;
  setVersion(value: number): void;

  hasTimestamp(): boolean;
  clearTimestamp(): void;
  getTimestamp(): google_protobuf_timestamp_pb.Timestamp | undefined;
  setTimestamp(value?: google_protobuf_timestamp_pb.Timestamp): void;

  hasResponse(): boolean;
  clearResponse(): void;
  getResponse(): Response | undefined;
  setResponse(value?: Response): void;

  getPayload(): Uint8Array | string;
  getPayload_asU8(): Uint8Array;
  getPayload_asB64(): string;
  setPayload(value: Uint8Array | string): void;

  hasEndorsement(): boolean;
  clearEndorsement(): void;
  getEndorsement(): Endorsement | undefined;
  setEndorsement(value?: Endorsement): void;

  hasInterest(): boolean;
  clearInterest(): void;
  getInterest(): ChaincodeInterest | undefined;
  setInterest(value?: ChaincodeInterest): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ProposalResponse.AsObject;
  static toObject(includeInstance: boolean, msg: ProposalResponse): ProposalResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ProposalResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ProposalResponse;
  static deserializeBinaryFromReader(message: ProposalResponse, reader: jspb.BinaryReader): ProposalResponse;
}

export namespace ProposalResponse {
  export type AsObject = {
    version: number,
    timestamp?: google_protobuf_timestamp_pb.Timestamp.AsObject,
    response?: Response.AsObject,
    payload: Uint8Array | string,
    endorsement?: Endorsement.AsObject,
    interest?: ChaincodeInterest.AsObject,
  }
}

export class Response extends jspb.Message {
  getStatus(): number;
  setStatus(value: number): void;

  getMessage(): string;
  setMessage(value: string): void;

  getPayload(): Uint8Array | string;
  getPayload_asU8(): Uint8Array;
  getPayload_asB64(): string;
  setPayload(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Response.AsObject;
  static toObject(includeInstance: boolean, msg: Response): Response.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Response, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Response;
  static deserializeBinaryFromReader(message: Response, reader: jspb.BinaryReader): Response;
}

export namespace Response {
  export type AsObject = {
    status: number,
    message: string,
    payload: Uint8Array | string,
  }
}

export class ProposalResponsePayload extends jspb.Message {
  getProposalHash(): Uint8Array | string;
  getProposalHash_asU8(): Uint8Array;
  getProposalHash_asB64(): string;
  setProposalHash(value: Uint8Array | string): void;

  getExtension$(): Uint8Array | string;
  getExtension_asU8(): Uint8Array;
  getExtension_asB64(): string;
  setExtension$(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ProposalResponsePayload.AsObject;
  static toObject(includeInstance: boolean, msg: ProposalResponsePayload): ProposalResponsePayload.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ProposalResponsePayload, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ProposalResponsePayload;
  static deserializeBinaryFromReader(message: ProposalResponsePayload, reader: jspb.BinaryReader): ProposalResponsePayload;
}

export namespace ProposalResponsePayload {
  export type AsObject = {
    proposalHash: Uint8Array | string,
    extension: Uint8Array | string,
  }
}

export class Endorsement extends jspb.Message {
  getEndorser(): Uint8Array | string;
  getEndorser_asU8(): Uint8Array;
  getEndorser_asB64(): string;
  setEndorser(value: Uint8Array | string): void;

  getSignature(): Uint8Array | string;
  getSignature_asU8(): Uint8Array;
  getSignature_asB64(): string;
  setSignature(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Endorsement.AsObject;
  static toObject(includeInstance: boolean, msg: Endorsement): Endorsement.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Endorsement, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Endorsement;
  static deserializeBinaryFromReader(message: Endorsement, reader: jspb.BinaryReader): Endorsement;
}

export namespace Endorsement {
  export type AsObject = {
    endorser: Uint8Array | string,
    signature: Uint8Array | string,
  }
}

export class ChaincodeInterest extends jspb.Message {
  clearChaincodesList(): void;
  getChaincodesList(): Array<ChaincodeCall>;
  setChaincodesList(value: Array<ChaincodeCall>): void;
  addChaincodes(value?: ChaincodeCall, index?: number): ChaincodeCall;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChaincodeInterest.AsObject;
  static toObject(includeInstance: boolean, msg: ChaincodeInterest): ChaincodeInterest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChaincodeInterest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChaincodeInterest;
  static deserializeBinaryFromReader(message: ChaincodeInterest, reader: jspb.BinaryReader): ChaincodeInterest;
}

export namespace ChaincodeInterest {
  export type AsObject = {
    chaincodesList: Array<ChaincodeCall.AsObject>,
  }
}

export class ChaincodeCall extends jspb.Message {
  getName(): string;
  setName(value: string): void;

  clearCollectionNamesList(): void;
  getCollectionNamesList(): Array<string>;
  setCollectionNamesList(value: Array<string>): void;
  addCollectionNames(value: string, index?: number): string;

  getNoPrivateReads(): boolean;
  setNoPrivateReads(value: boolean): void;

  getNoPublicWrites(): boolean;
  setNoPublicWrites(value: boolean): void;

  clearKeyPoliciesList(): void;
  getKeyPoliciesList(): Array<common_policies_pb.SignaturePolicyEnvelope>;
  setKeyPoliciesList(value: Array<common_policies_pb.SignaturePolicyEnvelope>): void;
  addKeyPolicies(value?: common_policies_pb.SignaturePolicyEnvelope, index?: number): common_policies_pb.SignaturePolicyEnvelope;

  getDisregardNamespacePolicy(): boolean;
  setDisregardNamespacePolicy(value: boolean): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChaincodeCall.AsObject;
  static toObject(includeInstance: boolean, msg: ChaincodeCall): ChaincodeCall.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChaincodeCall, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChaincodeCall;
  static deserializeBinaryFromReader(message: ChaincodeCall, reader: jspb.BinaryReader): ChaincodeCall;
}

export namespace ChaincodeCall {
  export type AsObject = {
    name: string,
    collectionNamesList: Array<string>,
    noPrivateReads: boolean,
    noPublicWrites: boolean,
    keyPoliciesList: Array<common_policies_pb.SignaturePolicyEnvelope.AsObject>,
    disregardNamespacePolicy: boolean,
  }
}

