// package: discovery
// file: discovery/protocol.proto

import * as jspb from "google-protobuf";
import * as gossip_message_pb from "../gossip/message_pb";
import * as msp_msp_config_pb from "../msp/msp_config_pb";
import * as peer_proposal_response_pb from "../peer/proposal_response_pb";

export class SignedRequest extends jspb.Message {
  getPayload(): Uint8Array | string;
  getPayload_asU8(): Uint8Array;
  getPayload_asB64(): string;
  setPayload(value: Uint8Array | string): void;

  getSignature(): Uint8Array | string;
  getSignature_asU8(): Uint8Array;
  getSignature_asB64(): string;
  setSignature(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SignedRequest.AsObject;
  static toObject(includeInstance: boolean, msg: SignedRequest): SignedRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SignedRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SignedRequest;
  static deserializeBinaryFromReader(message: SignedRequest, reader: jspb.BinaryReader): SignedRequest;
}

export namespace SignedRequest {
  export type AsObject = {
    payload: Uint8Array | string,
    signature: Uint8Array | string,
  }
}

export class Request extends jspb.Message {
  hasAuthentication(): boolean;
  clearAuthentication(): void;
  getAuthentication(): AuthInfo | undefined;
  setAuthentication(value?: AuthInfo): void;

  clearQueriesList(): void;
  getQueriesList(): Array<Query>;
  setQueriesList(value: Array<Query>): void;
  addQueries(value?: Query, index?: number): Query;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Request.AsObject;
  static toObject(includeInstance: boolean, msg: Request): Request.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Request, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Request;
  static deserializeBinaryFromReader(message: Request, reader: jspb.BinaryReader): Request;
}

export namespace Request {
  export type AsObject = {
    authentication?: AuthInfo.AsObject,
    queriesList: Array<Query.AsObject>,
  }
}

export class Response extends jspb.Message {
  clearResultsList(): void;
  getResultsList(): Array<QueryResult>;
  setResultsList(value: Array<QueryResult>): void;
  addResults(value?: QueryResult, index?: number): QueryResult;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Response.AsObject;
  static toObject(includeInstance: boolean, msg: Response): Response.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Response, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Response;
  static deserializeBinaryFromReader(message: Response, reader: jspb.BinaryReader): Response;
}

export namespace Response {
  export type AsObject = {
    resultsList: Array<QueryResult.AsObject>,
  }
}

export class AuthInfo extends jspb.Message {
  getClientIdentity(): Uint8Array | string;
  getClientIdentity_asU8(): Uint8Array;
  getClientIdentity_asB64(): string;
  setClientIdentity(value: Uint8Array | string): void;

  getClientTlsCertHash(): Uint8Array | string;
  getClientTlsCertHash_asU8(): Uint8Array;
  getClientTlsCertHash_asB64(): string;
  setClientTlsCertHash(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): AuthInfo.AsObject;
  static toObject(includeInstance: boolean, msg: AuthInfo): AuthInfo.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: AuthInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): AuthInfo;
  static deserializeBinaryFromReader(message: AuthInfo, reader: jspb.BinaryReader): AuthInfo;
}

export namespace AuthInfo {
  export type AsObject = {
    clientIdentity: Uint8Array | string,
    clientTlsCertHash: Uint8Array | string,
  }
}

export class Query extends jspb.Message {
  getChannel(): string;
  setChannel(value: string): void;

  hasConfigQuery(): boolean;
  clearConfigQuery(): void;
  getConfigQuery(): ConfigQuery | undefined;
  setConfigQuery(value?: ConfigQuery): void;

  hasPeerQuery(): boolean;
  clearPeerQuery(): void;
  getPeerQuery(): PeerMembershipQuery | undefined;
  setPeerQuery(value?: PeerMembershipQuery): void;

  hasCcQuery(): boolean;
  clearCcQuery(): void;
  getCcQuery(): ChaincodeQuery | undefined;
  setCcQuery(value?: ChaincodeQuery): void;

  hasLocalPeers(): boolean;
  clearLocalPeers(): void;
  getLocalPeers(): LocalPeerQuery | undefined;
  setLocalPeers(value?: LocalPeerQuery): void;

  getQueryCase(): Query.QueryCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Query.AsObject;
  static toObject(includeInstance: boolean, msg: Query): Query.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Query, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Query;
  static deserializeBinaryFromReader(message: Query, reader: jspb.BinaryReader): Query;
}

export namespace Query {
  export type AsObject = {
    channel: string,
    configQuery?: ConfigQuery.AsObject,
    peerQuery?: PeerMembershipQuery.AsObject,
    ccQuery?: ChaincodeQuery.AsObject,
    localPeers?: LocalPeerQuery.AsObject,
  }

  export enum QueryCase {
    QUERY_NOT_SET = 0,
    CONFIG_QUERY = 2,
    PEER_QUERY = 3,
    CC_QUERY = 4,
    LOCAL_PEERS = 5,
  }
}

export class QueryResult extends jspb.Message {
  hasError(): boolean;
  clearError(): void;
  getError(): Error | undefined;
  setError(value?: Error): void;

  hasConfigResult(): boolean;
  clearConfigResult(): void;
  getConfigResult(): ConfigResult | undefined;
  setConfigResult(value?: ConfigResult): void;

  hasCcQueryRes(): boolean;
  clearCcQueryRes(): void;
  getCcQueryRes(): ChaincodeQueryResult | undefined;
  setCcQueryRes(value?: ChaincodeQueryResult): void;

  hasMembers(): boolean;
  clearMembers(): void;
  getMembers(): PeerMembershipResult | undefined;
  setMembers(value?: PeerMembershipResult): void;

  getResultCase(): QueryResult.ResultCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): QueryResult.AsObject;
  static toObject(includeInstance: boolean, msg: QueryResult): QueryResult.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: QueryResult, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): QueryResult;
  static deserializeBinaryFromReader(message: QueryResult, reader: jspb.BinaryReader): QueryResult;
}

export namespace QueryResult {
  export type AsObject = {
    error?: Error.AsObject,
    configResult?: ConfigResult.AsObject,
    ccQueryRes?: ChaincodeQueryResult.AsObject,
    members?: PeerMembershipResult.AsObject,
  }

  export enum ResultCase {
    RESULT_NOT_SET = 0,
    ERROR = 1,
    CONFIG_RESULT = 2,
    CC_QUERY_RES = 3,
    MEMBERS = 4,
  }
}

export class ConfigQuery extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ConfigQuery.AsObject;
  static toObject(includeInstance: boolean, msg: ConfigQuery): ConfigQuery.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ConfigQuery, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ConfigQuery;
  static deserializeBinaryFromReader(message: ConfigQuery, reader: jspb.BinaryReader): ConfigQuery;
}

export namespace ConfigQuery {
  export type AsObject = {
  }
}

export class ConfigResult extends jspb.Message {
  getMspsMap(): jspb.Map<string, msp_msp_config_pb.FabricMSPConfig>;
  clearMspsMap(): void;
  getOrderersMap(): jspb.Map<string, Endpoints>;
  clearOrderersMap(): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ConfigResult.AsObject;
  static toObject(includeInstance: boolean, msg: ConfigResult): ConfigResult.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ConfigResult, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ConfigResult;
  static deserializeBinaryFromReader(message: ConfigResult, reader: jspb.BinaryReader): ConfigResult;
}

export namespace ConfigResult {
  export type AsObject = {
    mspsMap: Array<[string, msp_msp_config_pb.FabricMSPConfig.AsObject]>,
    orderersMap: Array<[string, Endpoints.AsObject]>,
  }
}

export class PeerMembershipQuery extends jspb.Message {
  hasFilter(): boolean;
  clearFilter(): void;
  getFilter(): peer_proposal_response_pb.ChaincodeInterest | undefined;
  setFilter(value?: peer_proposal_response_pb.ChaincodeInterest): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PeerMembershipQuery.AsObject;
  static toObject(includeInstance: boolean, msg: PeerMembershipQuery): PeerMembershipQuery.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PeerMembershipQuery, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PeerMembershipQuery;
  static deserializeBinaryFromReader(message: PeerMembershipQuery, reader: jspb.BinaryReader): PeerMembershipQuery;
}

export namespace PeerMembershipQuery {
  export type AsObject = {
    filter?: peer_proposal_response_pb.ChaincodeInterest.AsObject,
  }
}

export class PeerMembershipResult extends jspb.Message {
  getPeersByOrgMap(): jspb.Map<string, Peers>;
  clearPeersByOrgMap(): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PeerMembershipResult.AsObject;
  static toObject(includeInstance: boolean, msg: PeerMembershipResult): PeerMembershipResult.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PeerMembershipResult, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PeerMembershipResult;
  static deserializeBinaryFromReader(message: PeerMembershipResult, reader: jspb.BinaryReader): PeerMembershipResult;
}

export namespace PeerMembershipResult {
  export type AsObject = {
    peersByOrgMap: Array<[string, Peers.AsObject]>,
  }
}

export class ChaincodeQuery extends jspb.Message {
  clearInterestsList(): void;
  getInterestsList(): Array<peer_proposal_response_pb.ChaincodeInterest>;
  setInterestsList(value: Array<peer_proposal_response_pb.ChaincodeInterest>): void;
  addInterests(value?: peer_proposal_response_pb.ChaincodeInterest, index?: number): peer_proposal_response_pb.ChaincodeInterest;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChaincodeQuery.AsObject;
  static toObject(includeInstance: boolean, msg: ChaincodeQuery): ChaincodeQuery.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChaincodeQuery, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChaincodeQuery;
  static deserializeBinaryFromReader(message: ChaincodeQuery, reader: jspb.BinaryReader): ChaincodeQuery;
}

export namespace ChaincodeQuery {
  export type AsObject = {
    interestsList: Array<peer_proposal_response_pb.ChaincodeInterest.AsObject>,
  }
}

export class ChaincodeQueryResult extends jspb.Message {
  clearContentList(): void;
  getContentList(): Array<EndorsementDescriptor>;
  setContentList(value: Array<EndorsementDescriptor>): void;
  addContent(value?: EndorsementDescriptor, index?: number): EndorsementDescriptor;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ChaincodeQueryResult.AsObject;
  static toObject(includeInstance: boolean, msg: ChaincodeQueryResult): ChaincodeQueryResult.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ChaincodeQueryResult, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ChaincodeQueryResult;
  static deserializeBinaryFromReader(message: ChaincodeQueryResult, reader: jspb.BinaryReader): ChaincodeQueryResult;
}

export namespace ChaincodeQueryResult {
  export type AsObject = {
    contentList: Array<EndorsementDescriptor.AsObject>,
  }
}

export class LocalPeerQuery extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): LocalPeerQuery.AsObject;
  static toObject(includeInstance: boolean, msg: LocalPeerQuery): LocalPeerQuery.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: LocalPeerQuery, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): LocalPeerQuery;
  static deserializeBinaryFromReader(message: LocalPeerQuery, reader: jspb.BinaryReader): LocalPeerQuery;
}

export namespace LocalPeerQuery {
  export type AsObject = {
  }
}

export class EndorsementDescriptor extends jspb.Message {
  getChaincode(): string;
  setChaincode(value: string): void;

  getEndorsersByGroupsMap(): jspb.Map<string, Peers>;
  clearEndorsersByGroupsMap(): void;
  clearLayoutsList(): void;
  getLayoutsList(): Array<Layout>;
  setLayoutsList(value: Array<Layout>): void;
  addLayouts(value?: Layout, index?: number): Layout;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EndorsementDescriptor.AsObject;
  static toObject(includeInstance: boolean, msg: EndorsementDescriptor): EndorsementDescriptor.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EndorsementDescriptor, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EndorsementDescriptor;
  static deserializeBinaryFromReader(message: EndorsementDescriptor, reader: jspb.BinaryReader): EndorsementDescriptor;
}

export namespace EndorsementDescriptor {
  export type AsObject = {
    chaincode: string,
    endorsersByGroupsMap: Array<[string, Peers.AsObject]>,
    layoutsList: Array<Layout.AsObject>,
  }
}

export class Layout extends jspb.Message {
  getQuantitiesByGroupMap(): jspb.Map<string, number>;
  clearQuantitiesByGroupMap(): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Layout.AsObject;
  static toObject(includeInstance: boolean, msg: Layout): Layout.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Layout, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Layout;
  static deserializeBinaryFromReader(message: Layout, reader: jspb.BinaryReader): Layout;
}

export namespace Layout {
  export type AsObject = {
    quantitiesByGroupMap: Array<[string, number]>,
  }
}

export class Peers extends jspb.Message {
  clearPeersList(): void;
  getPeersList(): Array<Peer>;
  setPeersList(value: Array<Peer>): void;
  addPeers(value?: Peer, index?: number): Peer;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Peers.AsObject;
  static toObject(includeInstance: boolean, msg: Peers): Peers.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Peers, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Peers;
  static deserializeBinaryFromReader(message: Peers, reader: jspb.BinaryReader): Peers;
}

export namespace Peers {
  export type AsObject = {
    peersList: Array<Peer.AsObject>,
  }
}

export class Peer extends jspb.Message {
  hasStateInfo(): boolean;
  clearStateInfo(): void;
  getStateInfo(): gossip_message_pb.Envelope | undefined;
  setStateInfo(value?: gossip_message_pb.Envelope): void;

  hasMembershipInfo(): boolean;
  clearMembershipInfo(): void;
  getMembershipInfo(): gossip_message_pb.Envelope | undefined;
  setMembershipInfo(value?: gossip_message_pb.Envelope): void;

  getIdentity(): Uint8Array | string;
  getIdentity_asU8(): Uint8Array;
  getIdentity_asB64(): string;
  setIdentity(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Peer.AsObject;
  static toObject(includeInstance: boolean, msg: Peer): Peer.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Peer, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Peer;
  static deserializeBinaryFromReader(message: Peer, reader: jspb.BinaryReader): Peer;
}

export namespace Peer {
  export type AsObject = {
    stateInfo?: gossip_message_pb.Envelope.AsObject,
    membershipInfo?: gossip_message_pb.Envelope.AsObject,
    identity: Uint8Array | string,
  }
}

export class Error extends jspb.Message {
  getContent(): string;
  setContent(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Error.AsObject;
  static toObject(includeInstance: boolean, msg: Error): Error.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Error, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Error;
  static deserializeBinaryFromReader(message: Error, reader: jspb.BinaryReader): Error;
}

export namespace Error {
  export type AsObject = {
    content: string,
  }
}

export class Endpoints extends jspb.Message {
  clearEndpointList(): void;
  getEndpointList(): Array<Endpoint>;
  setEndpointList(value: Array<Endpoint>): void;
  addEndpoint(value?: Endpoint, index?: number): Endpoint;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Endpoints.AsObject;
  static toObject(includeInstance: boolean, msg: Endpoints): Endpoints.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Endpoints, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Endpoints;
  static deserializeBinaryFromReader(message: Endpoints, reader: jspb.BinaryReader): Endpoints;
}

export namespace Endpoints {
  export type AsObject = {
    endpointList: Array<Endpoint.AsObject>,
  }
}

export class Endpoint extends jspb.Message {
  getHost(): string;
  setHost(value: string): void;

  getPort(): number;
  setPort(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Endpoint.AsObject;
  static toObject(includeInstance: boolean, msg: Endpoint): Endpoint.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Endpoint, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Endpoint;
  static deserializeBinaryFromReader(message: Endpoint, reader: jspb.BinaryReader): Endpoint;
}

export namespace Endpoint {
  export type AsObject = {
    host: string,
    port: number,
  }
}

