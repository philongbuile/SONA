// package: gossip
// file: gossip/message.proto

import * as jspb from "google-protobuf";
import * as peer_collection_pb from "../peer/collection_pb";

export class Envelope extends jspb.Message {
  getPayload(): Uint8Array | string;
  getPayload_asU8(): Uint8Array;
  getPayload_asB64(): string;
  setPayload(value: Uint8Array | string): void;

  getSignature(): Uint8Array | string;
  getSignature_asU8(): Uint8Array;
  getSignature_asB64(): string;
  setSignature(value: Uint8Array | string): void;

  hasSecretEnvelope(): boolean;
  clearSecretEnvelope(): void;
  getSecretEnvelope(): SecretEnvelope | undefined;
  setSecretEnvelope(value?: SecretEnvelope): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Envelope.AsObject;
  static toObject(includeInstance: boolean, msg: Envelope): Envelope.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Envelope, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Envelope;
  static deserializeBinaryFromReader(message: Envelope, reader: jspb.BinaryReader): Envelope;
}

export namespace Envelope {
  export type AsObject = {
    payload: Uint8Array | string,
    signature: Uint8Array | string,
    secretEnvelope?: SecretEnvelope.AsObject,
  }
}

export class SecretEnvelope extends jspb.Message {
  getPayload(): Uint8Array | string;
  getPayload_asU8(): Uint8Array;
  getPayload_asB64(): string;
  setPayload(value: Uint8Array | string): void;

  getSignature(): Uint8Array | string;
  getSignature_asU8(): Uint8Array;
  getSignature_asB64(): string;
  setSignature(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SecretEnvelope.AsObject;
  static toObject(includeInstance: boolean, msg: SecretEnvelope): SecretEnvelope.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SecretEnvelope, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SecretEnvelope;
  static deserializeBinaryFromReader(message: SecretEnvelope, reader: jspb.BinaryReader): SecretEnvelope;
}

export namespace SecretEnvelope {
  export type AsObject = {
    payload: Uint8Array | string,
    signature: Uint8Array | string,
  }
}

export class Secret extends jspb.Message {
  hasInternalendpoint(): boolean;
  clearInternalendpoint(): void;
  getInternalendpoint(): string;
  setInternalendpoint(value: string): void;

  getContentCase(): Secret.ContentCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Secret.AsObject;
  static toObject(includeInstance: boolean, msg: Secret): Secret.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Secret, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Secret;
  static deserializeBinaryFromReader(message: Secret, reader: jspb.BinaryReader): Secret;
}

export namespace Secret {
  export type AsObject = {
    internalendpoint: string,
  }

  export enum ContentCase {
    CONTENT_NOT_SET = 0,
    INTERNALENDPOINT = 1,
  }
}

export class GossipMessage extends jspb.Message {
  getNonce(): number;
  setNonce(value: number): void;

  getChannel(): Uint8Array | string;
  getChannel_asU8(): Uint8Array;
  getChannel_asB64(): string;
  setChannel(value: Uint8Array | string): void;

  getTag(): GossipMessage.TagMap[keyof GossipMessage.TagMap];
  setTag(value: GossipMessage.TagMap[keyof GossipMessage.TagMap]): void;

  hasAliveMsg(): boolean;
  clearAliveMsg(): void;
  getAliveMsg(): AliveMessage | undefined;
  setAliveMsg(value?: AliveMessage): void;

  hasMemReq(): boolean;
  clearMemReq(): void;
  getMemReq(): MembershipRequest | undefined;
  setMemReq(value?: MembershipRequest): void;

  hasMemRes(): boolean;
  clearMemRes(): void;
  getMemRes(): MembershipResponse | undefined;
  setMemRes(value?: MembershipResponse): void;

  hasDataMsg(): boolean;
  clearDataMsg(): void;
  getDataMsg(): DataMessage | undefined;
  setDataMsg(value?: DataMessage): void;

  hasHello(): boolean;
  clearHello(): void;
  getHello(): GossipHello | undefined;
  setHello(value?: GossipHello): void;

  hasDataDig(): boolean;
  clearDataDig(): void;
  getDataDig(): DataDigest | undefined;
  setDataDig(value?: DataDigest): void;

  hasDataReq(): boolean;
  clearDataReq(): void;
  getDataReq(): DataRequest | undefined;
  setDataReq(value?: DataRequest): void;

  hasDataUpdate(): boolean;
  clearDataUpdate(): void;
  getDataUpdate(): DataUpdate | undefined;
  setDataUpdate(value?: DataUpdate): void;

  hasEmpty(): boolean;
  clearEmpty(): void;
  getEmpty(): Empty | undefined;
  setEmpty(value?: Empty): void;

  hasConn(): boolean;
  clearConn(): void;
  getConn(): ConnEstablish | undefined;
  setConn(value?: ConnEstablish): void;

  hasStateInfo(): boolean;
  clearStateInfo(): void;
  getStateInfo(): StateInfo | undefined;
  setStateInfo(value?: StateInfo): void;

  hasStateSnapshot(): boolean;
  clearStateSnapshot(): void;
  getStateSnapshot(): StateInfoSnapshot | undefined;
  setStateSnapshot(value?: StateInfoSnapshot): void;

  hasStateInfoPullReq(): boolean;
  clearStateInfoPullReq(): void;
  getStateInfoPullReq(): StateInfoPullRequest | undefined;
  setStateInfoPullReq(value?: StateInfoPullRequest): void;

  hasStateRequest(): boolean;
  clearStateRequest(): void;
  getStateRequest(): RemoteStateRequest | undefined;
  setStateRequest(value?: RemoteStateRequest): void;

  hasStateResponse(): boolean;
  clearStateResponse(): void;
  getStateResponse(): RemoteStateResponse | undefined;
  setStateResponse(value?: RemoteStateResponse): void;

  hasLeadershipMsg(): boolean;
  clearLeadershipMsg(): void;
  getLeadershipMsg(): LeadershipMessage | undefined;
  setLeadershipMsg(value?: LeadershipMessage): void;

  hasPeerIdentity(): boolean;
  clearPeerIdentity(): void;
  getPeerIdentity(): PeerIdentity | undefined;
  setPeerIdentity(value?: PeerIdentity): void;

  hasAck(): boolean;
  clearAck(): void;
  getAck(): Acknowledgement | undefined;
  setAck(value?: Acknowledgement): void;

  hasPrivatereq(): boolean;
  clearPrivatereq(): void;
  getPrivatereq(): RemotePvtDataRequest | undefined;
  setPrivatereq(value?: RemotePvtDataRequest): void;

  hasPrivateres(): boolean;
  clearPrivateres(): void;
  getPrivateres(): RemotePvtDataResponse | undefined;
  setPrivateres(value?: RemotePvtDataResponse): void;

  hasPrivateData(): boolean;
  clearPrivateData(): void;
  getPrivateData(): PrivateDataMessage | undefined;
  setPrivateData(value?: PrivateDataMessage): void;

  getContentCase(): GossipMessage.ContentCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GossipMessage.AsObject;
  static toObject(includeInstance: boolean, msg: GossipMessage): GossipMessage.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GossipMessage, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GossipMessage;
  static deserializeBinaryFromReader(message: GossipMessage, reader: jspb.BinaryReader): GossipMessage;
}

export namespace GossipMessage {
  export type AsObject = {
    nonce: number,
    channel: Uint8Array | string,
    tag: GossipMessage.TagMap[keyof GossipMessage.TagMap],
    aliveMsg?: AliveMessage.AsObject,
    memReq?: MembershipRequest.AsObject,
    memRes?: MembershipResponse.AsObject,
    dataMsg?: DataMessage.AsObject,
    hello?: GossipHello.AsObject,
    dataDig?: DataDigest.AsObject,
    dataReq?: DataRequest.AsObject,
    dataUpdate?: DataUpdate.AsObject,
    empty?: Empty.AsObject,
    conn?: ConnEstablish.AsObject,
    stateInfo?: StateInfo.AsObject,
    stateSnapshot?: StateInfoSnapshot.AsObject,
    stateInfoPullReq?: StateInfoPullRequest.AsObject,
    stateRequest?: RemoteStateRequest.AsObject,
    stateResponse?: RemoteStateResponse.AsObject,
    leadershipMsg?: LeadershipMessage.AsObject,
    peerIdentity?: PeerIdentity.AsObject,
    ack?: Acknowledgement.AsObject,
    privatereq?: RemotePvtDataRequest.AsObject,
    privateres?: RemotePvtDataResponse.AsObject,
    privateData?: PrivateDataMessage.AsObject,
  }

  export interface TagMap {
    UNDEFINED: 0;
    EMPTY: 1;
    ORG_ONLY: 2;
    CHAN_ONLY: 3;
    CHAN_AND_ORG: 4;
    CHAN_OR_ORG: 5;
  }

  export const Tag: TagMap;

  export enum ContentCase {
    CONTENT_NOT_SET = 0,
    ALIVE_MSG = 5,
    MEM_REQ = 6,
    MEM_RES = 7,
    DATA_MSG = 8,
    HELLO = 9,
    DATA_DIG = 10,
    DATA_REQ = 11,
    DATA_UPDATE = 12,
    EMPTY = 13,
    CONN = 14,
    STATE_INFO = 15,
    STATE_SNAPSHOT = 16,
    STATE_INFO_PULL_REQ = 17,
    STATE_REQUEST = 18,
    STATE_RESPONSE = 19,
    LEADERSHIP_MSG = 20,
    PEER_IDENTITY = 21,
    ACK = 22,
    PRIVATEREQ = 23,
    PRIVATERES = 24,
    PRIVATE_DATA = 25,
  }
}

export class StateInfo extends jspb.Message {
  hasTimestamp(): boolean;
  clearTimestamp(): void;
  getTimestamp(): PeerTime | undefined;
  setTimestamp(value?: PeerTime): void;

  getPkiId(): Uint8Array | string;
  getPkiId_asU8(): Uint8Array;
  getPkiId_asB64(): string;
  setPkiId(value: Uint8Array | string): void;

  getChannelMac(): Uint8Array | string;
  getChannelMac_asU8(): Uint8Array;
  getChannelMac_asB64(): string;
  setChannelMac(value: Uint8Array | string): void;

  hasProperties(): boolean;
  clearProperties(): void;
  getProperties(): Properties | undefined;
  setProperties(value?: Properties): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): StateInfo.AsObject;
  static toObject(includeInstance: boolean, msg: StateInfo): StateInfo.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: StateInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): StateInfo;
  static deserializeBinaryFromReader(message: StateInfo, reader: jspb.BinaryReader): StateInfo;
}

export namespace StateInfo {
  export type AsObject = {
    timestamp?: PeerTime.AsObject,
    pkiId: Uint8Array | string,
    channelMac: Uint8Array | string,
    properties?: Properties.AsObject,
  }
}

export class Properties extends jspb.Message {
  getLedgerHeight(): number;
  setLedgerHeight(value: number): void;

  getLeftChannel(): boolean;
  setLeftChannel(value: boolean): void;

  clearChaincodesList(): void;
  getChaincodesList(): Array<Chaincode>;
  setChaincodesList(value: Array<Chaincode>): void;
  addChaincodes(value?: Chaincode, index?: number): Chaincode;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Properties.AsObject;
  static toObject(includeInstance: boolean, msg: Properties): Properties.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Properties, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Properties;
  static deserializeBinaryFromReader(message: Properties, reader: jspb.BinaryReader): Properties;
}

export namespace Properties {
  export type AsObject = {
    ledgerHeight: number,
    leftChannel: boolean,
    chaincodesList: Array<Chaincode.AsObject>,
  }
}

export class StateInfoSnapshot extends jspb.Message {
  clearElementsList(): void;
  getElementsList(): Array<Envelope>;
  setElementsList(value: Array<Envelope>): void;
  addElements(value?: Envelope, index?: number): Envelope;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): StateInfoSnapshot.AsObject;
  static toObject(includeInstance: boolean, msg: StateInfoSnapshot): StateInfoSnapshot.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: StateInfoSnapshot, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): StateInfoSnapshot;
  static deserializeBinaryFromReader(message: StateInfoSnapshot, reader: jspb.BinaryReader): StateInfoSnapshot;
}

export namespace StateInfoSnapshot {
  export type AsObject = {
    elementsList: Array<Envelope.AsObject>,
  }
}

export class StateInfoPullRequest extends jspb.Message {
  getChannelMac(): Uint8Array | string;
  getChannelMac_asU8(): Uint8Array;
  getChannelMac_asB64(): string;
  setChannelMac(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): StateInfoPullRequest.AsObject;
  static toObject(includeInstance: boolean, msg: StateInfoPullRequest): StateInfoPullRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: StateInfoPullRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): StateInfoPullRequest;
  static deserializeBinaryFromReader(message: StateInfoPullRequest, reader: jspb.BinaryReader): StateInfoPullRequest;
}

export namespace StateInfoPullRequest {
  export type AsObject = {
    channelMac: Uint8Array | string,
  }
}

export class ConnEstablish extends jspb.Message {
  getPkiId(): Uint8Array | string;
  getPkiId_asU8(): Uint8Array;
  getPkiId_asB64(): string;
  setPkiId(value: Uint8Array | string): void;

  getIdentity(): Uint8Array | string;
  getIdentity_asU8(): Uint8Array;
  getIdentity_asB64(): string;
  setIdentity(value: Uint8Array | string): void;

  getTlsCertHash(): Uint8Array | string;
  getTlsCertHash_asU8(): Uint8Array;
  getTlsCertHash_asB64(): string;
  setTlsCertHash(value: Uint8Array | string): void;

  getProbe(): boolean;
  setProbe(value: boolean): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ConnEstablish.AsObject;
  static toObject(includeInstance: boolean, msg: ConnEstablish): ConnEstablish.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ConnEstablish, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ConnEstablish;
  static deserializeBinaryFromReader(message: ConnEstablish, reader: jspb.BinaryReader): ConnEstablish;
}

export namespace ConnEstablish {
  export type AsObject = {
    pkiId: Uint8Array | string,
    identity: Uint8Array | string,
    tlsCertHash: Uint8Array | string,
    probe: boolean,
  }
}

export class PeerIdentity extends jspb.Message {
  getPkiId(): Uint8Array | string;
  getPkiId_asU8(): Uint8Array;
  getPkiId_asB64(): string;
  setPkiId(value: Uint8Array | string): void;

  getCert(): Uint8Array | string;
  getCert_asU8(): Uint8Array;
  getCert_asB64(): string;
  setCert(value: Uint8Array | string): void;

  getMetadata(): Uint8Array | string;
  getMetadata_asU8(): Uint8Array;
  getMetadata_asB64(): string;
  setMetadata(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PeerIdentity.AsObject;
  static toObject(includeInstance: boolean, msg: PeerIdentity): PeerIdentity.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PeerIdentity, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PeerIdentity;
  static deserializeBinaryFromReader(message: PeerIdentity, reader: jspb.BinaryReader): PeerIdentity;
}

export namespace PeerIdentity {
  export type AsObject = {
    pkiId: Uint8Array | string,
    cert: Uint8Array | string,
    metadata: Uint8Array | string,
  }
}

export class DataRequest extends jspb.Message {
  getNonce(): number;
  setNonce(value: number): void;

  clearDigestsList(): void;
  getDigestsList(): Array<Uint8Array | string>;
  getDigestsList_asU8(): Array<Uint8Array>;
  getDigestsList_asB64(): Array<string>;
  setDigestsList(value: Array<Uint8Array | string>): void;
  addDigests(value: Uint8Array | string, index?: number): Uint8Array | string;

  getMsgType(): PullMsgTypeMap[keyof PullMsgTypeMap];
  setMsgType(value: PullMsgTypeMap[keyof PullMsgTypeMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DataRequest.AsObject;
  static toObject(includeInstance: boolean, msg: DataRequest): DataRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DataRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DataRequest;
  static deserializeBinaryFromReader(message: DataRequest, reader: jspb.BinaryReader): DataRequest;
}

export namespace DataRequest {
  export type AsObject = {
    nonce: number,
    digestsList: Array<Uint8Array | string>,
    msgType: PullMsgTypeMap[keyof PullMsgTypeMap],
  }
}

export class GossipHello extends jspb.Message {
  getNonce(): number;
  setNonce(value: number): void;

  getMetadata(): Uint8Array | string;
  getMetadata_asU8(): Uint8Array;
  getMetadata_asB64(): string;
  setMetadata(value: Uint8Array | string): void;

  getMsgType(): PullMsgTypeMap[keyof PullMsgTypeMap];
  setMsgType(value: PullMsgTypeMap[keyof PullMsgTypeMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GossipHello.AsObject;
  static toObject(includeInstance: boolean, msg: GossipHello): GossipHello.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GossipHello, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GossipHello;
  static deserializeBinaryFromReader(message: GossipHello, reader: jspb.BinaryReader): GossipHello;
}

export namespace GossipHello {
  export type AsObject = {
    nonce: number,
    metadata: Uint8Array | string,
    msgType: PullMsgTypeMap[keyof PullMsgTypeMap],
  }
}

export class DataUpdate extends jspb.Message {
  getNonce(): number;
  setNonce(value: number): void;

  clearDataList(): void;
  getDataList(): Array<Envelope>;
  setDataList(value: Array<Envelope>): void;
  addData(value?: Envelope, index?: number): Envelope;

  getMsgType(): PullMsgTypeMap[keyof PullMsgTypeMap];
  setMsgType(value: PullMsgTypeMap[keyof PullMsgTypeMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DataUpdate.AsObject;
  static toObject(includeInstance: boolean, msg: DataUpdate): DataUpdate.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DataUpdate, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DataUpdate;
  static deserializeBinaryFromReader(message: DataUpdate, reader: jspb.BinaryReader): DataUpdate;
}

export namespace DataUpdate {
  export type AsObject = {
    nonce: number,
    dataList: Array<Envelope.AsObject>,
    msgType: PullMsgTypeMap[keyof PullMsgTypeMap],
  }
}

export class DataDigest extends jspb.Message {
  getNonce(): number;
  setNonce(value: number): void;

  clearDigestsList(): void;
  getDigestsList(): Array<Uint8Array | string>;
  getDigestsList_asU8(): Array<Uint8Array>;
  getDigestsList_asB64(): Array<string>;
  setDigestsList(value: Array<Uint8Array | string>): void;
  addDigests(value: Uint8Array | string, index?: number): Uint8Array | string;

  getMsgType(): PullMsgTypeMap[keyof PullMsgTypeMap];
  setMsgType(value: PullMsgTypeMap[keyof PullMsgTypeMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DataDigest.AsObject;
  static toObject(includeInstance: boolean, msg: DataDigest): DataDigest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DataDigest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DataDigest;
  static deserializeBinaryFromReader(message: DataDigest, reader: jspb.BinaryReader): DataDigest;
}

export namespace DataDigest {
  export type AsObject = {
    nonce: number,
    digestsList: Array<Uint8Array | string>,
    msgType: PullMsgTypeMap[keyof PullMsgTypeMap],
  }
}

export class DataMessage extends jspb.Message {
  hasPayload(): boolean;
  clearPayload(): void;
  getPayload(): Payload | undefined;
  setPayload(value?: Payload): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DataMessage.AsObject;
  static toObject(includeInstance: boolean, msg: DataMessage): DataMessage.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DataMessage, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DataMessage;
  static deserializeBinaryFromReader(message: DataMessage, reader: jspb.BinaryReader): DataMessage;
}

export namespace DataMessage {
  export type AsObject = {
    payload?: Payload.AsObject,
  }
}

export class PrivateDataMessage extends jspb.Message {
  hasPayload(): boolean;
  clearPayload(): void;
  getPayload(): PrivatePayload | undefined;
  setPayload(value?: PrivatePayload): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PrivateDataMessage.AsObject;
  static toObject(includeInstance: boolean, msg: PrivateDataMessage): PrivateDataMessage.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PrivateDataMessage, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PrivateDataMessage;
  static deserializeBinaryFromReader(message: PrivateDataMessage, reader: jspb.BinaryReader): PrivateDataMessage;
}

export namespace PrivateDataMessage {
  export type AsObject = {
    payload?: PrivatePayload.AsObject,
  }
}

export class Payload extends jspb.Message {
  getSeqNum(): number;
  setSeqNum(value: number): void;

  getData(): Uint8Array | string;
  getData_asU8(): Uint8Array;
  getData_asB64(): string;
  setData(value: Uint8Array | string): void;

  clearPrivateDataList(): void;
  getPrivateDataList(): Array<Uint8Array | string>;
  getPrivateDataList_asU8(): Array<Uint8Array>;
  getPrivateDataList_asB64(): Array<string>;
  setPrivateDataList(value: Array<Uint8Array | string>): void;
  addPrivateData(value: Uint8Array | string, index?: number): Uint8Array | string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Payload.AsObject;
  static toObject(includeInstance: boolean, msg: Payload): Payload.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Payload, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Payload;
  static deserializeBinaryFromReader(message: Payload, reader: jspb.BinaryReader): Payload;
}

export namespace Payload {
  export type AsObject = {
    seqNum: number,
    data: Uint8Array | string,
    privateDataList: Array<Uint8Array | string>,
  }
}

export class PrivatePayload extends jspb.Message {
  getCollectionName(): string;
  setCollectionName(value: string): void;

  getNamespace(): string;
  setNamespace(value: string): void;

  getTxId(): string;
  setTxId(value: string): void;

  getPrivateRwset(): Uint8Array | string;
  getPrivateRwset_asU8(): Uint8Array;
  getPrivateRwset_asB64(): string;
  setPrivateRwset(value: Uint8Array | string): void;

  getPrivateSimHeight(): number;
  setPrivateSimHeight(value: number): void;

  hasCollectionConfigs(): boolean;
  clearCollectionConfigs(): void;
  getCollectionConfigs(): peer_collection_pb.CollectionConfigPackage | undefined;
  setCollectionConfigs(value?: peer_collection_pb.CollectionConfigPackage): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PrivatePayload.AsObject;
  static toObject(includeInstance: boolean, msg: PrivatePayload): PrivatePayload.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PrivatePayload, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PrivatePayload;
  static deserializeBinaryFromReader(message: PrivatePayload, reader: jspb.BinaryReader): PrivatePayload;
}

export namespace PrivatePayload {
  export type AsObject = {
    collectionName: string,
    namespace: string,
    txId: string,
    privateRwset: Uint8Array | string,
    privateSimHeight: number,
    collectionConfigs?: peer_collection_pb.CollectionConfigPackage.AsObject,
  }
}

export class AliveMessage extends jspb.Message {
  hasMembership(): boolean;
  clearMembership(): void;
  getMembership(): Member | undefined;
  setMembership(value?: Member): void;

  hasTimestamp(): boolean;
  clearTimestamp(): void;
  getTimestamp(): PeerTime | undefined;
  setTimestamp(value?: PeerTime): void;

  getIdentity(): Uint8Array | string;
  getIdentity_asU8(): Uint8Array;
  getIdentity_asB64(): string;
  setIdentity(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): AliveMessage.AsObject;
  static toObject(includeInstance: boolean, msg: AliveMessage): AliveMessage.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: AliveMessage, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): AliveMessage;
  static deserializeBinaryFromReader(message: AliveMessage, reader: jspb.BinaryReader): AliveMessage;
}

export namespace AliveMessage {
  export type AsObject = {
    membership?: Member.AsObject,
    timestamp?: PeerTime.AsObject,
    identity: Uint8Array | string,
  }
}

export class LeadershipMessage extends jspb.Message {
  getPkiId(): Uint8Array | string;
  getPkiId_asU8(): Uint8Array;
  getPkiId_asB64(): string;
  setPkiId(value: Uint8Array | string): void;

  hasTimestamp(): boolean;
  clearTimestamp(): void;
  getTimestamp(): PeerTime | undefined;
  setTimestamp(value?: PeerTime): void;

  getIsDeclaration(): boolean;
  setIsDeclaration(value: boolean): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): LeadershipMessage.AsObject;
  static toObject(includeInstance: boolean, msg: LeadershipMessage): LeadershipMessage.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: LeadershipMessage, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): LeadershipMessage;
  static deserializeBinaryFromReader(message: LeadershipMessage, reader: jspb.BinaryReader): LeadershipMessage;
}

export namespace LeadershipMessage {
  export type AsObject = {
    pkiId: Uint8Array | string,
    timestamp?: PeerTime.AsObject,
    isDeclaration: boolean,
  }
}

export class PeerTime extends jspb.Message {
  getIncNum(): number;
  setIncNum(value: number): void;

  getSeqNum(): number;
  setSeqNum(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PeerTime.AsObject;
  static toObject(includeInstance: boolean, msg: PeerTime): PeerTime.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PeerTime, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PeerTime;
  static deserializeBinaryFromReader(message: PeerTime, reader: jspb.BinaryReader): PeerTime;
}

export namespace PeerTime {
  export type AsObject = {
    incNum: number,
    seqNum: number,
  }
}

export class MembershipRequest extends jspb.Message {
  hasSelfInformation(): boolean;
  clearSelfInformation(): void;
  getSelfInformation(): Envelope | undefined;
  setSelfInformation(value?: Envelope): void;

  clearKnownList(): void;
  getKnownList(): Array<Uint8Array | string>;
  getKnownList_asU8(): Array<Uint8Array>;
  getKnownList_asB64(): Array<string>;
  setKnownList(value: Array<Uint8Array | string>): void;
  addKnown(value: Uint8Array | string, index?: number): Uint8Array | string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MembershipRequest.AsObject;
  static toObject(includeInstance: boolean, msg: MembershipRequest): MembershipRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MembershipRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MembershipRequest;
  static deserializeBinaryFromReader(message: MembershipRequest, reader: jspb.BinaryReader): MembershipRequest;
}

export namespace MembershipRequest {
  export type AsObject = {
    selfInformation?: Envelope.AsObject,
    knownList: Array<Uint8Array | string>,
  }
}

export class MembershipResponse extends jspb.Message {
  clearAliveList(): void;
  getAliveList(): Array<Envelope>;
  setAliveList(value: Array<Envelope>): void;
  addAlive(value?: Envelope, index?: number): Envelope;

  clearDeadList(): void;
  getDeadList(): Array<Envelope>;
  setDeadList(value: Array<Envelope>): void;
  addDead(value?: Envelope, index?: number): Envelope;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MembershipResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MembershipResponse): MembershipResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MembershipResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MembershipResponse;
  static deserializeBinaryFromReader(message: MembershipResponse, reader: jspb.BinaryReader): MembershipResponse;
}

export namespace MembershipResponse {
  export type AsObject = {
    aliveList: Array<Envelope.AsObject>,
    deadList: Array<Envelope.AsObject>,
  }
}

export class Member extends jspb.Message {
  getEndpoint(): string;
  setEndpoint(value: string): void;

  getMetadata(): Uint8Array | string;
  getMetadata_asU8(): Uint8Array;
  getMetadata_asB64(): string;
  setMetadata(value: Uint8Array | string): void;

  getPkiId(): Uint8Array | string;
  getPkiId_asU8(): Uint8Array;
  getPkiId_asB64(): string;
  setPkiId(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Member.AsObject;
  static toObject(includeInstance: boolean, msg: Member): Member.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Member, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Member;
  static deserializeBinaryFromReader(message: Member, reader: jspb.BinaryReader): Member;
}

export namespace Member {
  export type AsObject = {
    endpoint: string,
    metadata: Uint8Array | string,
    pkiId: Uint8Array | string,
  }
}

export class Empty extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Empty.AsObject;
  static toObject(includeInstance: boolean, msg: Empty): Empty.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Empty, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Empty;
  static deserializeBinaryFromReader(message: Empty, reader: jspb.BinaryReader): Empty;
}

export namespace Empty {
  export type AsObject = {
  }
}

export class RemoteStateRequest extends jspb.Message {
  getStartSeqNum(): number;
  setStartSeqNum(value: number): void;

  getEndSeqNum(): number;
  setEndSeqNum(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): RemoteStateRequest.AsObject;
  static toObject(includeInstance: boolean, msg: RemoteStateRequest): RemoteStateRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: RemoteStateRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): RemoteStateRequest;
  static deserializeBinaryFromReader(message: RemoteStateRequest, reader: jspb.BinaryReader): RemoteStateRequest;
}

export namespace RemoteStateRequest {
  export type AsObject = {
    startSeqNum: number,
    endSeqNum: number,
  }
}

export class RemoteStateResponse extends jspb.Message {
  clearPayloadsList(): void;
  getPayloadsList(): Array<Payload>;
  setPayloadsList(value: Array<Payload>): void;
  addPayloads(value?: Payload, index?: number): Payload;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): RemoteStateResponse.AsObject;
  static toObject(includeInstance: boolean, msg: RemoteStateResponse): RemoteStateResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: RemoteStateResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): RemoteStateResponse;
  static deserializeBinaryFromReader(message: RemoteStateResponse, reader: jspb.BinaryReader): RemoteStateResponse;
}

export namespace RemoteStateResponse {
  export type AsObject = {
    payloadsList: Array<Payload.AsObject>,
  }
}

export class RemotePvtDataRequest extends jspb.Message {
  clearDigestsList(): void;
  getDigestsList(): Array<PvtDataDigest>;
  setDigestsList(value: Array<PvtDataDigest>): void;
  addDigests(value?: PvtDataDigest, index?: number): PvtDataDigest;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): RemotePvtDataRequest.AsObject;
  static toObject(includeInstance: boolean, msg: RemotePvtDataRequest): RemotePvtDataRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: RemotePvtDataRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): RemotePvtDataRequest;
  static deserializeBinaryFromReader(message: RemotePvtDataRequest, reader: jspb.BinaryReader): RemotePvtDataRequest;
}

export namespace RemotePvtDataRequest {
  export type AsObject = {
    digestsList: Array<PvtDataDigest.AsObject>,
  }
}

export class PvtDataDigest extends jspb.Message {
  getTxId(): string;
  setTxId(value: string): void;

  getNamespace(): string;
  setNamespace(value: string): void;

  getCollection(): string;
  setCollection(value: string): void;

  getBlockSeq(): number;
  setBlockSeq(value: number): void;

  getSeqInBlock(): number;
  setSeqInBlock(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PvtDataDigest.AsObject;
  static toObject(includeInstance: boolean, msg: PvtDataDigest): PvtDataDigest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PvtDataDigest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PvtDataDigest;
  static deserializeBinaryFromReader(message: PvtDataDigest, reader: jspb.BinaryReader): PvtDataDigest;
}

export namespace PvtDataDigest {
  export type AsObject = {
    txId: string,
    namespace: string,
    collection: string,
    blockSeq: number,
    seqInBlock: number,
  }
}

export class RemotePvtDataResponse extends jspb.Message {
  clearElementsList(): void;
  getElementsList(): Array<PvtDataElement>;
  setElementsList(value: Array<PvtDataElement>): void;
  addElements(value?: PvtDataElement, index?: number): PvtDataElement;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): RemotePvtDataResponse.AsObject;
  static toObject(includeInstance: boolean, msg: RemotePvtDataResponse): RemotePvtDataResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: RemotePvtDataResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): RemotePvtDataResponse;
  static deserializeBinaryFromReader(message: RemotePvtDataResponse, reader: jspb.BinaryReader): RemotePvtDataResponse;
}

export namespace RemotePvtDataResponse {
  export type AsObject = {
    elementsList: Array<PvtDataElement.AsObject>,
  }
}

export class PvtDataElement extends jspb.Message {
  hasDigest(): boolean;
  clearDigest(): void;
  getDigest(): PvtDataDigest | undefined;
  setDigest(value?: PvtDataDigest): void;

  clearPayloadList(): void;
  getPayloadList(): Array<Uint8Array | string>;
  getPayloadList_asU8(): Array<Uint8Array>;
  getPayloadList_asB64(): Array<string>;
  setPayloadList(value: Array<Uint8Array | string>): void;
  addPayload(value: Uint8Array | string, index?: number): Uint8Array | string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PvtDataElement.AsObject;
  static toObject(includeInstance: boolean, msg: PvtDataElement): PvtDataElement.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PvtDataElement, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PvtDataElement;
  static deserializeBinaryFromReader(message: PvtDataElement, reader: jspb.BinaryReader): PvtDataElement;
}

export namespace PvtDataElement {
  export type AsObject = {
    digest?: PvtDataDigest.AsObject,
    payloadList: Array<Uint8Array | string>,
  }
}

export class PvtDataPayload extends jspb.Message {
  getTxSeqInBlock(): number;
  setTxSeqInBlock(value: number): void;

  getPayload(): Uint8Array | string;
  getPayload_asU8(): Uint8Array;
  getPayload_asB64(): string;
  setPayload(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PvtDataPayload.AsObject;
  static toObject(includeInstance: boolean, msg: PvtDataPayload): PvtDataPayload.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PvtDataPayload, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PvtDataPayload;
  static deserializeBinaryFromReader(message: PvtDataPayload, reader: jspb.BinaryReader): PvtDataPayload;
}

export namespace PvtDataPayload {
  export type AsObject = {
    txSeqInBlock: number,
    payload: Uint8Array | string,
  }
}

export class Acknowledgement extends jspb.Message {
  getError(): string;
  setError(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Acknowledgement.AsObject;
  static toObject(includeInstance: boolean, msg: Acknowledgement): Acknowledgement.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Acknowledgement, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Acknowledgement;
  static deserializeBinaryFromReader(message: Acknowledgement, reader: jspb.BinaryReader): Acknowledgement;
}

export namespace Acknowledgement {
  export type AsObject = {
    error: string,
  }
}

export class Chaincode extends jspb.Message {
  getName(): string;
  setName(value: string): void;

  getVersion(): string;
  setVersion(value: string): void;

  getMetadata(): Uint8Array | string;
  getMetadata_asU8(): Uint8Array;
  getMetadata_asB64(): string;
  setMetadata(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Chaincode.AsObject;
  static toObject(includeInstance: boolean, msg: Chaincode): Chaincode.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Chaincode, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Chaincode;
  static deserializeBinaryFromReader(message: Chaincode, reader: jspb.BinaryReader): Chaincode;
}

export namespace Chaincode {
  export type AsObject = {
    name: string,
    version: string,
    metadata: Uint8Array | string,
  }
}

export interface PullMsgTypeMap {
  UNDEFINED: 0;
  BLOCK_MSG: 1;
  IDENTITY_MSG: 2;
}

export const PullMsgType: PullMsgTypeMap;

